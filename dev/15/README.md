### Небольшой фрагмент кода — проблемы и решение
> Рассмотреть следующий код и ответить на вопросы: к каким негативным последствиям он может привести и как это исправить?
> Приведите корректный пример реализации.
```
var justString string

func someFunc() {
  v := createHugeString(1 &lt;&lt; 10)
  justString = v[:100]
}

func main() {
  someFunc()
}
```
> Вопрос: что происходит с переменной justString?\

### Негативное последствие: Утечка памяти (Memory Leak).

> Когда мы делаем срез строки, Go не копирует данные строки. Вместо этого срез указывает на часть исходной строки в памяти. В данном случае, justString указывает на первые 100 символов большой строки v. Проблема в том, что вся исходная строка v (1024 символа) остается в памяти, пока существует ссылка на нее (пока существует justString). Даже если мы не используем остальную часть строки v , она всё равно занимает память. Если someFunc вызывается многократно, это может привести к значительному потреблению памяти.
> Решение:
> Чтобы избежать утечки памяти, необходимо создать копию подстроки, а не просто срез. Это можно сделать, преобразовав подстроку в новый string.